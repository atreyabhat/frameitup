<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frame it Up | Add Borders and 35mm Film Frames</title>
    <meta name="description" content="By a photographer, for photographers. The free, ad-free online tool to add simple, elegant frames and 35mm film borders to your pictures for posting or printing.">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
        }
        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        .file-input-container input[type=file] {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
        .bg-pattern {
            background-color: #f3f4f6; /* gray-100 */
            background-image: radial-gradient(circle, #d1d5db 1px, transparent 1px), radial-gradient(circle, #d1d5db 1px, transparent 1px); /* gray-300 */
            background-size: 40px 40px;
            background-position: 0 0, 20px 20px;
            
        }
        @media (prefers-color-scheme: dark) {
            .bg-pattern {
                background-color: #1f2937; /* gray-800 */
                background-image: radial-gradient(circle, #4b5563 1px, transparent 1px), radial-gradient(circle, #4b5563 1px, transparent 1px); /* gray-600 */
            }
        }
    </style>
</head>
<body class="bg-pattern text-gray-800 dark:text-gray-200 min-h-screen flex flex-col items-center p-4 pt-16">

    <div class="bg-white dark:bg-gray-800 p-8 pb-12 rounded-xl shadow-lg w-full max-w-6xl min-h-[36rem] flex flex-col relative">
        <div class="absolute top-4 right-4 flex space-x-2">
            
        </div>
        <h1 class="text-3xl font-bold mb-2 text-center text-gray-900 dark:text-white">Frame it Up</h1>
        
        <!-- Tool Description and Donation Section -->
        <div class="text-center mb-8 space-y-2">
            <p class="text-sm text-gray-600 dark:text-gray-400">
                 By a photographer, for photographers. Effortlessly add clean, elegant frames to your images for social media or printing.
                <br>Simple & ad-free experience.
            </p>
            <!-- <p class="text-sm font-semibold text-gray-700 dark:text-gray-300">
                If you appreciate this tool, your support helps keep it running.
                <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=YOUR_PAYPAL_EMAIL&item_name=Frame%20it%20Up%20Donation&currency_code=USD" target="_blank" rel="noopener noreferrer" class="text-blue-500 hover:text-blue-600 underline">Donate to support this project</a>.
            </p> -->
        </div>

        <div class="space-y-6 flex-grow flex flex-col justify-center">
            <!-- File Selection -->
            <div class="flex flex-col items-center">
                <label for="file-upload" class="sr-only">Choose Images</label>
                <div class="file-input-container">
                    <button class="bg-blue-500 text-white font-semibold py-3 px-6 rounded-lg hover:bg-blue-600 transition-colors duration-300 shadow-md">
                        Select Images
                    </button>
                    <input id="file-upload" type="file" multiple accept="image/*" />
                </div>
                <p id="file-count" class="mt-2 text-sm text-gray-500 dark:text-gray-400">No images selected</p>
            </div>

            <!-- Border Settings -->
            <div class="border-t border-gray-200 dark:border-gray-700 pt-6 space-y-4">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Border Width -->
                    <div id="border-width-container" class="transition-opacity duration-300">
                        <label for="border-width" class="block text-sm font-medium mb-1">Border Width (pixels)</label>
                        <input type="number" id="border-width" value="200" min="0" max="1000" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg p-2.5 text-gray-900 dark:text-white focus:ring-blue-500 focus:border-blue-500">
                        <input type="range" id="border-width-slider" min="0" max="1000" value="200" step="25" class="mt-2 w-full h-2 bg-gray-300 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    
                    <!-- Border Color -->
                    <div>
                        <label class="block text-sm font-medium mb-1">Border Color</label>
                        <div class="flex flex-wrap gap-x-4 gap-y-2">
                            <label class="inline-flex items-center">
                                <input type="radio" name="border-color" value="white" checked class="form-radio text-blue-600 border-gray-300 dark:border-gray-600 focus:ring-blue-500">
                                <span class="ml-2 text-gray-700 dark:text-gray-300">White</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="border-color" value="black" class="form-radio text-blue-600 border-gray-300 dark:border-gray-600 focus:ring-blue-500">
                                <span class="ml-2 text-gray-700 dark:text-gray-300">Black</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="border-color" value="average" class="form-radio text-blue-600 border-gray-300 dark:border-gray-600 focus:ring-blue-500">
                                <span class="ml-2 text-gray-700 dark:text-gray-300">Average Color</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="border-color" value="film" class="form-radio text-blue-600 border-gray-300 dark:border-gray-600 focus:ring-blue-500">
                                <span class="ml-2 text-gray-700 dark:text-gray-300">35  MM Film</span>
                            </label>
                        </div>
                    </div>
                    <!-- Corner Radius -->
                    <div id="corner-radius-container" class="transition-opacity duration-300">
                        <label for="corner-radius" class="block text-sm font-medium mb-1">Corner Radius (pixels)</label>
                        <input type="number" id="corner-radius-input" value="0" min="0" max="500" class="w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg p-2.5 text-gray-900 dark:text-white focus:ring-blue-500 focus:border-blue-500">
                        <input type="range" id="corner-radius" min="0" max="500" value="0" step="50" class="mt-2 w-full h-2 bg-gray-300 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex justify-center md:justify-between items-center mt-8 space-x-4">
                <div class="flex items-center gap-4">
                    <button id="process-button" class="bg-gray-400 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition-colors duration-300 cursor-not-allowed" disabled>
                        <span id="process-text">Process Images</span>
                    </button>
                    <span id="loading-text" class="hidden text-gray-700 dark:text-gray-300 font-semibold text-lg w-32 text-left"></span>
                </div>
                <div class="flex items-center space-x-4">
                    <button id="download-all-button" class="bg-gray-400 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition-colors duration-300 cursor-not-allowed" disabled>
                        Download All (ZIP)
                    </button>
                    <button id="reset-button" class="bg-gray-400 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition-colors duration-300 cursor-not-allowed" disabled>
                        Reset
                    </button>
                </div>
            </div>

            <!-- Message & Output -->
            <div id="message-container" class="mt-16 text-center"></div>
        </div>
        
        <!-- Uploaded Images and Processed Images -->
        <div id="image-output" class="mt-8 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('file-upload');
            const fileCount = document.getElementById('file-count');
            const borderWidthInput = document.getElementById('border-width');
            const borderWidthSlider = document.getElementById('border-width-slider');
            const cornerRadiusInput = document.getElementById('corner-radius');
            const cornerRadiusNumberInput = document.getElementById('corner-radius-input');
            const processButton = document.getElementById('process-button');
            const downloadAllButton = document.getElementById('download-all-button');
            const borderColorRadios = document.getElementsByName('border-color');
            const imageOutput = document.getElementById('image-output');
            const messageContainer = document.getElementById('message-container');
            const resetButton = document.getElementById('reset-button');
            const processText = document.getElementById('process-text');
            const loadingText = document.getElementById('loading-text');
            const borderWidthContainer = document.getElementById('border-width-container');
            const cornerRadiusContainer = document.getElementById('corner-radius-container');
            
            let selectedFiles = [];
            const loadedImages = [];
            let processedImages = [];
            let initialLoadComplete = false;
            let loadingInterval;
            
            function getAverageColor(img) {
                return new Promise(resolve => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 1;
                    canvas.height = 1;
                    ctx.drawImage(img, 0, 0, 1, 1);
                    const [r, g, b] = ctx.getImageData(0, 0, 1, 1).data;
                    resolve(`rgb(${r}, ${g}, ${b})`);
                });
            }

            function drawRoundedRect(ctx, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            }

            // --- FILM FRAME DRAWING LOGIC ---

            function drawVerticalFilmFrame(ctx, width, height, img) {
                const originalWidth = img.naturalWidth;
                const originalHeight = img.naturalHeight;

                const filmStripWidth = width * 0.08;
                const topBorderHeight = height * 0.02;
                const imageAreaWidth = width - (2 * filmStripWidth);
                const imageAreaHeight = height - (2 * topBorderHeight);
                
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, width, height);

                const imageRatio = originalWidth / originalHeight;
                let newImageHeight = imageAreaHeight;
                let newImageWidth = newImageHeight * imageRatio;

                if (newImageWidth > imageAreaWidth) {
                    newImageWidth = imageAreaWidth;
                    newImageHeight = newImageWidth / imageRatio;
                }

                const imageX = filmStripWidth + (imageAreaWidth - newImageWidth) / 2;
                const imageY = topBorderHeight + (imageAreaHeight - newImageHeight) / 2;
                
                ctx.save();
                ctx.filter = 'saturate(0.8)';
                ctx.drawImage(img, imageX, imageY, newImageWidth, newImageHeight);
                ctx.restore();

                // --- Draw Text & Markings (Rotated) ---
                const drawRotatedContent = (stripX, isPrimaryStrip) => {
                    ctx.save();
                    ctx.translate(stripX, height / 2);
                    const isLeftStrip = stripX < width / 2;
                    ctx.rotate(isLeftStrip ? Math.PI / 2 : -Math.PI / 2);
                    
                    const stripLength = height;
                    const stripWidth = filmStripWidth;

                    if (isPrimaryStrip) {
                        ctx.fillStyle = '#f59e0b'; // amber-500
                        const fontSize = stripWidth * 0.4;
                        ctx.font = `bold ${fontSize}px "Poppins", sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        const positions = [];
                        const minDistance = stripLength * 0.15;

                        // Generate positions for text and two arrows, ensuring they don't overlap
                        const textX = stripLength * (Math.random() * 0.6 - 0.3);
                        positions.push(textX);
                        
                        let arrow1X;
                        do {
                            arrow1X = stripLength * (Math.random() * 0.6 + 0.2);
                        } while (Math.abs(arrow1X - textX) < minDistance);
                        positions.push(arrow1X);

                        let arrow2X;
                        do {
                            arrow2X = stripLength * (Math.random() * 0.6 + 0.2);
                        } while (Math.abs(arrow2X - textX) < minDistance || Math.abs(arrow2X - arrow1X) < minDistance);
                        positions.push(arrow2X);

                        ctx.fillText('35  MM', textX, 0);

                        const arrowHeight = stripWidth * 0.35;
                        const arrowWidth = arrowHeight * 1.2;

                        [arrow1X, arrow2X].forEach(x => {
                            ctx.beginPath();
                            ctx.moveTo(x, -arrowWidth / 2);
                            ctx.lineTo(x + arrowHeight, 0);
                            ctx.lineTo(x, arrowWidth/2);
                            ctx.closePath();
                            ctx.fill();
                        });
                    }
                    
                    // Barcode Pattern
                    if (!isLeftStrip) { // Only draw for the right strip
                        ctx.fillStyle = '#f59e0b'; // amber-500
                        const pattern = [0.6, 0.3, 0.6, 0.3, 0.6, 0.3, 0.9, 0.3, 0.6, 0.3, 0.6, 0.3, 0.6, 0, 0, 0.6, 0.3, 0.6, 0.3, 0.9, 0.3, 0.6, 0.3, 0.6, 0, 0, 0.9, 0.3, 0.3, 0.6];
                        const barThickness = stripWidth * 0.08;
                        const gapAlongStrip = stripWidth * 0.04;
                        let currentPosAlongStrip = -stripLength / 2 * 0.95;
                        const endPosAlongStrip = stripLength / 2 * 0.95;
                        
                        const posAcrossStrip = -stripWidth * 0.1; // Inner edge is negative Y after rotation for right strip

                        while (currentPosAlongStrip < endPosAlongStrip) {
                            for (let i = 0; i < pattern.length && currentPosAlongStrip < endPosAlongStrip; i++) {
                                const lengthMultiplier = pattern[i];
                                if (lengthMultiplier > 0) {
                                    const barLength = -(stripWidth * 0.5 * lengthMultiplier); // Draw in negative direction for right strip
                                    ctx.fillRect(currentPosAlongStrip, posAcrossStrip, barThickness, barLength);
                                }
                                currentPosAlongStrip += barThickness + gapAlongStrip;
                            }
                        }
                    }

                    ctx.restore();
                };
                
                drawRotatedContent(filmStripWidth / 2, true); // Left strip with text
                drawRotatedContent(width - filmStripWidth / 2, false); // Right strip without text


                // --- Draw sprocket holes ---
                ctx.fillStyle = 'white';
                const holeWidth = filmStripWidth * 0.6;
                const holeHeight = holeWidth * 0.7; 
                const holeRadius = holeHeight * 0.4; 
                const numHoles = Math.floor(height / (holeHeight * 2.2));

                for (let i = 0; i < numHoles; i++) {
                    const holeY = (i * (height / numHoles)) + (height / numHoles - holeHeight) / 2;
                    // Left holes
                    drawRoundedRect(ctx, (filmStripWidth - holeWidth) / 2, holeY, holeWidth, holeHeight, holeRadius);
                    ctx.fill();
                    // Right holes
                    drawRoundedRect(ctx, width - filmStripWidth + (filmStripWidth - holeWidth) / 2, holeY, holeWidth, holeHeight, holeRadius);
                    ctx.fill();
                }
            }


            function drawHorizontalFilmFrame(ctx, width, height, img) {
                const originalWidth = img.naturalWidth;
                const originalHeight = img.naturalHeight;

                const filmStripHeight = height * 0.08;
                const sideBorderWidth = width * 0.02;
                const imageAreaHeight = height - (2 * filmStripHeight);
                const imageAreaWidth = width - (2 * sideBorderWidth);
                
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, width, height);

                const imageRatio = originalWidth / originalHeight;
                let newImageWidth = imageAreaWidth;
                let newImageHeight = newImageWidth / imageRatio;

                if (newImageHeight > imageAreaHeight) {
                    newImageHeight = imageAreaHeight;
                    newImageWidth = newImageHeight * imageRatio;
                }

                const imageX = sideBorderWidth + (imageAreaWidth - newImageWidth) / 2;
                const imageY = filmStripHeight + (imageAreaHeight - newImageHeight) / 2;
                
                ctx.save();
                ctx.filter = 'saturate(0.8)';
                ctx.drawImage(img, imageX, imageY, newImageWidth, newImageHeight);
                ctx.restore();

                ctx.fillStyle = '#f59e0b'; // amber-500
                const fontSize = filmStripHeight * 0.4;
                ctx.font = `bold ${fontSize}px "Poppins", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const positions = [];
                const minDistance = width * 0.15;

                // Generate positions for text and two arrows, ensuring they don't overlap
                const textX = width * (Math.random() * 0.6 + 0.2);
                positions.push(textX);
                
                let arrow1X;
                do {
                    arrow1X = width * (Math.random() * 0.6 + 0.2);
                } while (Math.abs(arrow1X - textX) < minDistance);
                positions.push(arrow1X);

                let arrow2X;
                do {
                    arrow2X = width * (Math.random() * 0.6 + 0.2);
                } while (Math.abs(arrow2X - textX) < minDistance || Math.abs(arrow2X - arrow1X) < minDistance);
                positions.push(arrow2X);

                const textY = filmStripHeight / 2;
                ctx.fillText('35  MM', textX, textY);

                const arrowHeight = filmStripHeight * 0.35;
                const arrowWidth = arrowHeight * 1.2;
                const arrowY = filmStripHeight / 2;

                [arrow1X, arrow2X].forEach(x => {
                    ctx.beginPath();
                    ctx.moveTo(x - arrowWidth / 2, arrowY - arrowHeight / 2);
                    ctx.lineTo(x - arrowWidth / 2, arrowY + arrowHeight / 2);
                    ctx.lineTo(x + arrowWidth / 2, arrowY);
                    ctx.closePath();
                    ctx.fill();
                });

                const drawAuthenticBarcodes = (y) => {
                    const pattern = [0.6, 0.3, 0.6, 0.3, 0.6, 0.3, 0.9, 0.3, 0.6, 0.3, 0.6, 0.3, 0.6, 0, 0, 0.6, 0.3, 0.6, 0.3, 0.9, 0.3, 0.6, 0.3, 0.6, 0, 0, 0.9, 0.3, 0.3, 0.6];
                    const barWidth = width * 0.008;
                    const gapWidth = width * 0.004;
                    let currentX = width * 0.05;
                    const endX = width * 0.95;

                    while (currentX < endX) {
                        for (let i = 0; i < pattern.length && currentX < endX; i++) {
                            const heightMultiplier = pattern[i];
                            if (heightMultiplier > 0) {
                                const barHeight = filmStripHeight * 0.5 * heightMultiplier;
                                const barY = y + (filmStripHeight * 0.5 * (1 - heightMultiplier));
                                ctx.fillRect(currentX, barY, barWidth, barHeight);
                            }
                            currentX += barWidth + gapWidth;
                        }
                    }
                };
                
                drawAuthenticBarcodes(height - filmStripHeight * 0.7);

                ctx.fillStyle = 'white';
                const holeHeight = filmStripHeight * 0.6;
                const holeWidth = holeHeight * 1.2;
                const holeRadius = holeWidth * 0.2; 
                const numHoles = Math.floor(width / (holeWidth * 2.2));

                for (let i = 0; i < numHoles; i++) {
                    const holeX = (i * (width / numHoles)) + (width / numHoles - holeWidth) / 2;
                    drawRoundedRect(ctx, holeX, (filmStripHeight - holeHeight) / 2, holeWidth, holeHeight, holeRadius);
                    ctx.fill();
                    drawRoundedRect(ctx, holeX, height - filmStripHeight + (filmStripHeight - holeHeight) / 2, holeWidth, holeHeight, holeRadius);
                    ctx.fill();
                }
            }

            function drawFramedPreview(img, canvas, borderWidth, borderColor, cornerRadius) {
                const ctx = canvas.getContext('2d');
                const originalWidth = img.naturalWidth;
                const originalHeight = img.naturalHeight;
                const isPortrait = originalWidth < originalHeight;
                
                const maxDimension = 300;
                canvas.width = maxDimension;
                canvas.height = maxDimension;
                ctx.clearRect(0, 0, maxDimension, maxDimension);
                
                if (borderColor === 'film') {
                    const filmRatio = isPortrait ? 2/3 : 3/2;
                    let filmWidth, filmHeight, offsetX, offsetY;

                    if (isPortrait) {
                        filmHeight = maxDimension;
                        filmWidth = maxDimension * filmRatio;
                        offsetX = (maxDimension - filmWidth) / 2;
                        offsetY = 0;
                    } else {
                        filmWidth = maxDimension;
                        filmHeight = maxDimension / filmRatio;
                        offsetX = 0;
                        offsetY = (maxDimension - filmHeight) / 2;
                    }

                    ctx.save();
                    ctx.translate(offsetX, offsetY);
                    if (isPortrait) {
                        drawVerticalFilmFrame(ctx, filmWidth, filmHeight, img);
                    } else {
                        drawHorizontalFilmFrame(ctx, filmWidth, filmHeight, img);
                    }
                    ctx.restore();
                    return;
                }

                const newWidth = originalWidth + 2 * borderWidth;
                const newHeight = originalHeight + 2 * borderWidth;
                const ratio = Math.min(maxDimension / newWidth, maxDimension / newHeight);
                const scaledWidth = newWidth * ratio;
                const scaledHeight = newHeight * ratio;
                const offsetX = (maxDimension - scaledWidth) / 2;
                const offsetY = (maxDimension - scaledHeight) / 2;

                const drawCanvasContents = (frameColor) => {
                    ctx.fillStyle = frameColor;
                    ctx.fillRect(offsetX, offsetY, scaledWidth, scaledHeight);
                    ctx.save();
                    drawRoundedRect(ctx, borderWidth * ratio + offsetX, borderWidth * ratio + offsetY, (originalWidth * ratio), (originalHeight * ratio), cornerRadius * ratio);
                    ctx.clip();
                    ctx.drawImage(img, borderWidth * ratio + offsetX, borderWidth * ratio + offsetY, (originalWidth * ratio), (originalHeight * ratio));
                    ctx.restore();
                };

                if (borderColor === 'average') {
                    if (img.averageColor) {
                        drawCanvasContents(img.averageColor);
                    } else {
                        getAverageColor(img).then(avgColor => {
                            img.averageColor = avgColor;
                            drawCanvasContents(avgColor);
                        });
                    }
                } else {
                    drawCanvasContents(borderColor);
                }
            }

            function updateAllPreviews() {
                const borderWidth = parseInt(borderWidthInput.value, 10);
                const borderColor = document.querySelector('input[name="border-color"]:checked').value;
                const cornerRadius = parseInt(cornerRadiusInput.value, 10);
                
                const isFilm = borderColor === 'film';
                borderWidthInput.disabled = isFilm;
                borderWidthSlider.disabled = isFilm;
                cornerRadiusInput.disabled = isFilm;
                cornerRadiusNumberInput.disabled = isFilm;

                borderWidthContainer.classList.toggle('opacity-50', isFilm);
                cornerRadiusContainer.classList.toggle('opacity-50', isFilm);

                loadedImages.forEach(item => {
                    const previewCanvas = item.element.querySelector('canvas');
                    if (item.img.complete && item.img.naturalWidth > 0) {
                        drawFramedPreview(item.img, previewCanvas, borderWidth, borderColor, cornerRadius);
                    }
                });
            }

            // --- EVENT LISTENERS ---
            borderWidthInput.addEventListener('input', () => {
                const value = Math.max(0, Math.min(1000, parseInt(borderWidthInput.value, 10) || 0));
                borderWidthInput.value = value;
                borderWidthSlider.value = value;
                if (processedImages.length > 0) resetToPreviewMode();
                updateAllPreviews();
            });
            borderWidthSlider.addEventListener('input', () => {
                borderWidthInput.value = borderWidthSlider.value;
                if (processedImages.length > 0) resetToPreviewMode();
                updateAllPreviews();
            });
            borderColorRadios.forEach(radio => radio.addEventListener('change', () => {
                if (processedImages.length > 0) resetToPreviewMode();
                updateAllPreviews();
            }));
            cornerRadiusInput.addEventListener('input', () => {
                cornerRadiusNumberInput.value = cornerRadiusInput.value;
                if (processedImages.length > 0) resetToPreviewMode();
                updateAllPreviews();
            });
            cornerRadiusNumberInput.addEventListener('input', () => {
                const value = Math.max(0, Math.min(500, parseInt(cornerRadiusNumberInput.value, 10) || 0));
                cornerRadiusNumberInput.value = value;
                cornerRadiusInput.value = value;
                if (processedImages.length > 0) resetToPreviewMode();
                updateAllPreviews();
            });

            fileInput.addEventListener('change', (event) => {
                selectedFiles = Array.from(event.target.files);
                loadedImages.length = 0;
                processedImages.length = 0;
                imageOutput.innerHTML = '';
                messageContainer.textContent = '';
                downloadAllButton.disabled = true;
                downloadAllButton.classList.add('bg-gray-400', 'cursor-not-allowed');
                downloadAllButton.classList.remove('bg-purple-500', 'hover:bg-purple-600');
                
                resetButton.disabled = true;
                resetButton.classList.add('bg-gray-400', 'cursor-not-allowed');
                resetButton.classList.remove('bg-red-600', 'hover:bg-red-700');

                if (selectedFiles.length > 0) {
                    fileCount.textContent = `${selectedFiles.length} image(s) selected.`;
                    processButton.disabled = false;
                    processButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
                    processButton.classList.add('bg-green-500', 'hover:bg-green-600');
                    
                    resetButton.disabled = false;
                    resetButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
                    resetButton.classList.add('bg-red-600', 'hover:bg-red-700');

                    initialLoadComplete = false;

                    selectedFiles.forEach(file => {
                        const container = document.createElement('div');
                        container.className = 'bg-gray-50 dark:bg-gray-700 rounded-lg p-2 shadow-sm text-center';
                        const canvas = document.createElement('canvas');
                        canvas.className = 'w-full h-auto rounded mb-2 mx-auto';
                        const name = document.createElement('p');
                        name.className = 'text-xs truncate text-gray-700 dark:text-gray-300';
                        name.textContent = file.name;

                        container.appendChild(canvas);
                        container.appendChild(name);
                        imageOutput.appendChild(container);

                        const img = new Image();
                        img.onload = () => {
                            loadedImages.push({ file, img, element: container });
                            updateAllPreviews();
                            if (loadedImages.length === selectedFiles.length) {
                                initialLoadComplete = true;
                            }
                        };
                        const reader = new FileReader();
                        reader.onload = (e) => img.src = e.target.result;
                        reader.readAsDataURL(file);
                    });
                } else {
                    fileCount.textContent = 'No images selected';
                    processButton.disabled = true;
                    processButton.classList.add('bg-gray-400', 'cursor-not-allowed');
                    processButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                }
            });

            // --- PROCESSING & UI ---
            function startLoadingAnimation() {
                let dots = 1;
                loadingText.classList.remove('hidden');
                loadingInterval = setInterval(() => {
                    loadingText.textContent = 'Loading ' + '. '.repeat(dots);
                    dots = (dots % 3) + 1;
                }, 400);
            }

            function stopLoadingAnimation() {
                clearInterval(loadingInterval);
                loadingText.classList.add('hidden');
            }

            processButton.addEventListener('click', () => {
                if (selectedFiles.length === 0) {
                    showMessage('Please select at least one image.', 'text-red-500');
                    return;
                }
                const borderWidth = parseInt(borderWidthInput.value, 10);
                if (isNaN(borderWidth) || borderWidth < 0) {
                    showMessage('Please enter a valid border width.', 'text-red-500');
                    return;
                }
                messageContainer.textContent = '';
                processButton.disabled = true;
                startLoadingAnimation();
                processedImages = [];
                processImagesSequentially(0);
            });

            function processImagesSequentially(index) {
                if (index >= loadedImages.length) {
                    displayProcessedImages();
                    showMessage('Images processed successfully!', 'text-green-500');
                    downloadAllButton.disabled = false;
                    downloadAllButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
                    downloadAllButton.classList.add('bg-purple-500', 'hover:bg-purple-600');
                    processButton.disabled = false;
                    stopLoadingAnimation();
                    resetButton.disabled = false;
                    resetButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
                    resetButton.classList.add('bg-red-600', 'hover:bg-red-700');
                    return;
                }
                const item = loadedImages[index];
                const borderWidth = parseInt(borderWidthInput.value, 10);
                const cornerRadius = parseInt(cornerRadiusInput.value, 10);
                const borderColor = document.querySelector('input[name="border-color"]:checked').value;

                processImage(item.img, (dataUrl) => {
                    const originalName = item.file.name.split('.')[0];
                    const newName = `${originalName}_framed.jpg`;
                    processedImages.push({ name: newName, url: dataUrl });
                    setTimeout(() => processImagesSequentially(index + 1), 0);
                }, borderWidth, borderColor, cornerRadius);
            }

            function processImage(img, callback, borderWidth, borderColor, cornerRadius) {
                const originalWidth = img.naturalWidth;
                const originalHeight = img.naturalHeight;
                const isPortrait = originalWidth < originalHeight;
                
                if (borderColor === 'film') {
                    const finalImageRatio = isPortrait ? 2/3 : 3/2;
                    let filmWidth, filmHeight;
                    const sidePercentage = 0.02; 
                    const stripPercentage = 0.08;

                    if (isPortrait) {
                        filmHeight = Math.round(originalHeight / (1 - 2 * sidePercentage));
                        filmWidth = Math.round(filmHeight * finalImageRatio);
                    } else {
                        filmWidth = Math.round(originalWidth / (1 - 2 * sidePercentage));
                        filmHeight = Math.round(filmWidth / finalImageRatio);
                    }
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = filmWidth;
                    canvas.height = filmHeight;
                    const ctx = canvas.getContext('2d');
                    
                    if (isPortrait) {
                        drawVerticalFilmFrame(ctx, filmWidth, filmHeight, img);
                    } else {
                        drawHorizontalFilmFrame(ctx, filmWidth, filmHeight, img);
                    }
                    callback(canvas.toDataURL('image/jpeg', 0.9));
                    return;
                }

                const framedWidth = originalWidth + 2 * borderWidth;
                const framedHeight = originalHeight + 2 * borderWidth;
                const canvas = document.createElement('canvas');
                canvas.width = framedWidth;
                canvas.height = framedHeight;
                const ctx = canvas.getContext('2d');

                const drawFinalImage = (frameColor) => {
                    ctx.fillStyle = frameColor;
                    ctx.fillRect(0, 0, framedWidth, framedHeight);
                    ctx.save();
                    drawRoundedRect(ctx, borderWidth, borderWidth, originalWidth, originalHeight, cornerRadius);
                    ctx.clip();
                    ctx.drawImage(img, borderWidth, borderWidth);
                    ctx.restore();
                    callback(canvas.toDataURL('image/jpeg', 0.9));
                };

                if (borderColor === 'average') {
                    getAverageColor(img).then(drawFinalImage);
                } else {
                    drawFinalImage(borderColor);
                }
            }
            
            function displayProcessedImages() {
                imageOutput.innerHTML = '';
                processedImages.forEach(item => {
                    const container = document.createElement('div');
                    container.className = 'bg-gray-50 dark:bg-gray-700 rounded-lg p-2 shadow-sm text-center';
                    const canvas = document.createElement('canvas');
                    canvas.className = 'w-full h-auto rounded mb-2 mx-auto';
                    const maxDimension = 300;
                    canvas.width = maxDimension;
                    canvas.height = maxDimension;
                    const ctx = canvas.getContext('2d');

                    const img = new Image();
                    img.onload = () => {
                        const ratio = Math.min(maxDimension / img.width, maxDimension / img.height);
                        const scaledWidth = img.width * ratio;
                        const scaledHeight = img.height * ratio;
                        const offsetX = (maxDimension - scaledWidth) / 2;
                        const offsetY = (maxDimension - scaledHeight) / 2;
                        ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
                    };
                    img.src = item.url;
                    
                    const link = document.createElement('a');
                    link.href = item.url;
                    link.download = item.name;
                    link.textContent = `Download`;
                    link.className = 'text-blue-500 hover:underline text-base font-semibold';

                    container.appendChild(canvas);
                    container.appendChild(link);
                    imageOutput.appendChild(container);
                });
            }

            downloadAllButton.addEventListener('click', () => {
                if (processedImages.length === 0) {
                    showMessage('No processed images to download.', 'text-red-500');
                    return;
                }
                showMessage('Preparing zip file for download...', 'text-blue-500');
                const zip = new JSZip();
                processedImages.forEach(item => {
                    const base64Data = item.url.split(',')[1];
                    zip.file(item.name, base64Data, { base64: true });
                });
                zip.generateAsync({ type: "blob" })
                    .then(content => {
                        saveAs(content, "framed_images.zip");
                        showMessage('Download started!', 'text-green-500');
                    })
                    .catch(e => {
                        showMessage('Error creating zip file.', 'text-red-500');
                        console.error(e);
                    });
            });

            resetButton.addEventListener('click', () => resetApplication());

            function resetApplication() {
                loadedImages.length = 0;
                processedImages.length = 0;
                imageOutput.innerHTML = '';
                messageContainer.textContent = '';
                processButton.disabled = true;
                processButton.classList.add('bg-gray-400', 'cursor-not-allowed');
                processButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                downloadAllButton.disabled = true;
                downloadAllButton.classList.add('bg-gray-400', 'cursor-not-allowed');
                downloadAllButton.classList.remove('bg-purple-500', 'hover:bg-purple-600');
                resetButton.disabled = true;
                resetButton.classList.add('bg-gray-400', 'cursor-not-allowed');
                resetButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                fileInput.value = null;
                fileCount.textContent = 'No images selected';
            }

            function resetToPreviewMode() {
                imageOutput.innerHTML = '';
                processedImages.length = 0;
                downloadAllButton.disabled = true;
                downloadAllButton.classList.add('bg-gray-400', 'cursor-not-allowed');
                downloadAllButton.classList.remove('bg-purple-500', 'hover:bg-purple-600');
                loadedImages.forEach(item => imageOutput.appendChild(item.element));
                updateAllPreviews();
            }

            function showMessage(msg, colorClass) {
                messageContainer.textContent = msg;
                messageContainer.className = `mt-16 text-center text-lg font-semibold ${colorClass}`;
            }
        });
    </script>

</body>
</html>
